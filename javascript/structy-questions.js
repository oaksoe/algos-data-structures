// max/min
// time: O(n), space: O(n)
const max = () => {

}

const min = () => {

}

// isPrime
// time: O(n), space: O(n)
const isPrime = () => {

}

/* Array and String */

// uncompress
// time: O(n), space: O(n)
const uncompress = () => {

}

// compress
// time: O(n), space: O(n)
const compress = () => {

}

// anagrams
// time: O(n), space: O(n)
const anagrams = () => {

}

// most freq chars in a string
// time: O(n), space: O(n)
const mostFreq = () => {

}

// pair sum/product
// time: O(n), space: O(n)
const pairSum = () => {

}

const pairProduct = () => {

}

// check in
// time: O(n), space: O(n)
const checkin = () => {

}

// intersection
// time: O(n), space: O(n)
const intersection = () => {

}

// five sort
// time: O(n), space: O(n)
const fiveSort = () => {

}

/* Linked list */

// reverse list
// time: O(n), space: O(n)
const reverseList = () => {

}

// zipper list
// time: O(n), space: O(n)
const zipperList = () => {

}

/* Binary Trees */

// depth first values
// time: O(n), space: O(n)
const dfv = () => {

}

// breadth first values
// time: O(n), space: O(n)
const bfv = () => {

}

// tree sum
// time: O(n), space: O(n)
const treeSum = () => {

}

// tree includes
// time: O(n), space: O(n)
const treeIncludes = () => {

}

// tree min value
// time: O(n), space: O(n)
const treeMinValue = () => {

}

// max root to leaf path sum
// time: O(n), space: O(n)
const maxRootToLeafPathSum = () => {

}

// path finder
// time: O(n), space: O(n)
const pathFinder = () => {

}

// tree value count
// time: O(n), space: O(n)
const treeValueCount = () => {

}

// how high
// time: O(n), space: O(n)
const treeHeight = () => {

}

// bottom right value
// time: O(n), space: O(n)
const bottomRight = () => {

}

// all tree paths
// time: O(n), space: O(n)
const allTreePaths = () => {

}

// tree levels
// time: O(n), space: O(n)
const treeLevels = () => {

}

// level averages
// time: O(n), space: O(n)
const levelAvg = () => {

}

// leaf list
// time: O(n), space: O(n)
const leafList = () => {

}

/* Graph */

// has path
// time: O(n), space: O(n)
const hasPath = () => {

}

// undirected path
// time: O(n), space: O(n)
const undirectedPath = () => {

}

// connected components count
// time: O(n), space: O(n)
const ccc = () => {

}

// largest component
// time: O(n), space: O(n)
const largestComp = () => {

}

// shortest path
// time: O(n), space: O(n)
const shortestPath = () => {

}

// island count
// time: O(n), space: O(n)
const islandCount = () => {

}

// minimum island
// time: O(n), space: O(n)
const minIsland = () => {

}

// closest carrot
// time: O(n), space: O(n)
const closestCarrot = () => {

}

// longest path
// time: O(n), space: O(n)
const longestPath = () => {

}

// semesters required
// time: O(n), space: O(n)
const semestersRequired = () => {

}

// best bridge
// time: O(n), space: O(n)
const bestBridge = () => {

}

// has cycle
// time: O(n), space: O(n)
const hasCycle = () => {

}

// prereqs possible
// time: O(n), space: O(n)
const prereqs = () => {

}

/* Stack */

// paired parentheses
// time: O(n), space: O(n)
const PairedParen = () => {

}

// befitting brackets
// time: O(n), space: O(n)
const befittingBrackets = () => {

}

// decompress braces
// time: O(n), space: O(n)
const decompressBraces = () => {

}

// nesting score
// time: O(n), space: O(n)
const nestingScore = () => {

}

/* Dynamic Programming */
// fibonacci
const fib = (n) => {

}

// sum possible
const sumPossible = (amount, numbers, memo = {}) => {

};

// min change
const minChange = (amount, coins) => {
    
};

// count paths
const countPaths = (grid) => {
    
};

/* Exhaustive Recursiion */

/* Mixed Recall */